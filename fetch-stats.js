#!/usr/bin/env node

const https = require('https');
const fs = require('fs');

const STATS_URL = 'https://www.smogon.com/stats/2026-01/moveset/gen9vgc2026regf-1500.txt';
const OUTPUT_FILE = 'spreads-data.js';
const MAX_SPREADS = 10;

function fetch(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        return fetch(res.headers.location).then(resolve, reject);
      }
      if (res.statusCode !== 200) {
        return reject(new Error(`HTTP ${res.statusCode}`));
      }
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => resolve(data));
      res.on('error', reject);
    }).on('error', reject);
  });
}

function parseSpreads(text) {
  const result = {};
  const lines = text.split('\n');

  let currentName = null;
  let inSpreads = false;
  let spreads = [];

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();
    const trimmed = line.trim();

    // Separator line — reset spreads section tracking
    if (/^\s*\+[-+]+\+\s*$/.test(trimmed)) {
      // If we were in spreads, save and reset
      if (inSpreads && currentName && spreads.length > 0) {
        result[currentName] = spreads.slice(0, MAX_SPREADS);
        spreads = [];
      }
      inSpreads = false;
      continue;
    }

    // Check for Pokemon name line (first content line after separator, looks like "| Name |")
    // Name lines have content that is NOT a section header and NOT a stat line
    const nameMatch = trimmed.match(/^\|\s*([A-Za-z][A-Za-z0-9\s.'-]+?)\s*\|$/);
    if (nameMatch) {
      const candidate = nameMatch[1].trim();
      // Section headers we want to skip
      const sections = ['Abilities', 'Items', 'Spreads', 'Moves', 'Tera Types', 'Teammates', 'Checks and Counters'];
      if (!sections.includes(candidate) && !candidate.match(/^\d/) && !candidate.includes('%')) {
        // Save previous Pokemon data if any
        if (currentName && spreads.length > 0) {
          result[currentName] = spreads.slice(0, MAX_SPREADS);
        }
        currentName = candidate;
        spreads = [];
        inSpreads = false;
        continue;
      }
    }

    // Detect Spreads section header
    if (/^\s*\|\s*Spreads\s*\|/.test(trimmed)) {
      inSpreads = true;
      continue;
    }

    // Parse spread lines when in Spreads section
    if (inSpreads) {
      const content = trimmed.replace(/^\|/, '').replace(/\|\s*$/, '').trim();
      if (content.match(/[A-Za-z]+:\d+\/\d+\/\d+\/\d+\/\d+\/\d+/)) {
        parseSingleSpread(content, spreads);
      }
    }
  }

  // Save last Pokemon
  if (currentName && spreads.length > 0) {
    result[currentName] = spreads.slice(0, MAX_SPREADS);
  }

  return result;
}

function parseSingleSpread(text, spreads) {
  // Format: Nature:HP/Atk/Def/SpA/SpD/Spe usage%
  // e.g. "Timid:0/0/0/252/4/252 10.298%"
  const match = text.match(/([A-Za-z]+):(\d+)\/(\d+)\/(\d+)\/(\d+)\/(\d+)\/(\d+)\s+([\d.]+)%/);
  if (match) {
    spreads.push({
      nature: match[1],
      evs: {
        hp: parseInt(match[2]),
        atk: parseInt(match[3]),
        def: parseInt(match[4]),
        spa: parseInt(match[5]),
        spd: parseInt(match[6]),
        spe: parseInt(match[7]),
      },
      usage: parseFloat(match[8]),
    });
  }
}

async function main() {
  console.log(`Fetching stats from ${STATS_URL}...`);
  let text;
  try {
    text = await fetch(STATS_URL);
  } catch (err) {
    console.error(`Failed to fetch stats: ${err.message}`);
    process.exit(1);
  }

  console.log(`Downloaded ${text.length} bytes, parsing...`);
  const spreads = parseSpreads(text);
  const count = Object.keys(spreads).length;
  console.log(`Parsed spreads for ${count} Pokemon`);

  const js = `// Auto-generated by fetch-stats.js — do not edit\nwindow.SPREADS_DATA = ${JSON.stringify(spreads, null, 2)};\n`;
  fs.writeFileSync(OUTPUT_FILE, js);
  console.log(`Wrote ${OUTPUT_FILE} (${(js.length / 1024).toFixed(1)} KB)`);
}

main();
